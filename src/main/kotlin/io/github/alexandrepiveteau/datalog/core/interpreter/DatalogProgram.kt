package io.github.alexandrepiveteau.datalog.core.interpreter

import io.github.alexandrepiveteau.datalog.core.Algorithm
import io.github.alexandrepiveteau.datalog.core.Domain
import io.github.alexandrepiveteau.datalog.core.Program
import io.github.alexandrepiveteau.datalog.core.interpreter.algebra.forEach
import io.github.alexandrepiveteau.datalog.core.interpreter.database.FactsDatabase
import io.github.alexandrepiveteau.datalog.core.interpreter.database.PredicateWithArity
import io.github.alexandrepiveteau.datalog.core.interpreter.database.RulesDatabase
import io.github.alexandrepiveteau.datalog.core.interpreter.ir.Database.Companion.Base
import io.github.alexandrepiveteau.datalog.core.interpreter.ir.Database.Companion.Result
import io.github.alexandrepiveteau.datalog.core.interpreter.ir.StorageManager
import io.github.alexandrepiveteau.datalog.core.interpreter.ir.compute
import io.github.alexandrepiveteau.datalog.core.rule.*

private fun <T> List<Atom<T>>.constants(): Sequence<Value<T>> {
  return sequence {
    for (atom in this@constants) {
      when (atom) {
        is Value -> yield(atom)
        else -> Unit
      }
    }
  }
}

private fun <T> Rule<T>.constants(): Sequence<Value<T>> {
  return sequence {
    yieldAll(head.atoms.constants())
    for (clause in body) {
      yieldAll(clause.atoms.constants())
    }
  }
}

private fun <T> constants(rules: RulesDatabase<T>, facts: FactsDatabase<T>): Sequence<Value<T>> {
  val values = sequence {
    for (predicate in rules) for (rule in rules[predicate]) yieldAll(rule.constants())
    for (predicate in facts) facts[predicate].forEach { yieldAll(it) }
  }
  // TODO : This is a temporary workaround to make sure the values are not recomputed each time the
  //        Context is used. This is to avoid constants generated by aggregates to show up in the
  //        domain, especially if the rules are properly grounded.
  return values.toSet().asSequence()
}

/**
 * An implementation of [Program] to obtain results.
 *
 * @param domain the [Domain] of the program.
 * @param rules the [Rule]s of the program.
 * @param algorithm the [Algorithm] used to evaluate each stratum.
 */
internal class DatalogProgram<out T>(
    private val domain: Domain<T>,
    private val rules: MutableSet<Rule<T>>,
    private val algorithm: Algorithm,
) : Program<T> {

  private fun context(idb: RulesDatabase<T>, edb: FactsDatabase<T>): Context<T> {
    return Context(atoms = constants(idb, edb), domain = domain)
  }

  override fun solve(predicate: Predicate, arity: Int): Iterable<Fact<T>> {
    val (idb, edb) = partition(rules)
    val target = PredicateWithArity(predicate, arity)
    val context = context(idb, edb)
    val storage = StorageManager<T>().apply { database(Base) += edb }
    stratifiedEval(target, idb, Base, Result) { i, e, r -> algorithm.evaluate(context, i, e, r) }
        .apply { compute(storage) }
    val result = storage.database(Base)
    return result[target].tuples
  }
}

package io.github.alexandrepiveteau.datalog.core.interpreter

import io.github.alexandrepiveteau.datalog.core.Fact
import io.github.alexandrepiveteau.datalog.core.Predicate
import io.github.alexandrepiveteau.datalog.core.Program
import io.github.alexandrepiveteau.datalog.core.interpreter.algebra.Relation
import io.github.alexandrepiveteau.datalog.core.interpreter.algebra.forEach
import io.github.alexandrepiveteau.datalog.core.interpreter.database.FactsDatabase
import io.github.alexandrepiveteau.datalog.core.interpreter.database.PredicateWithArity
import io.github.alexandrepiveteau.datalog.core.interpreter.database.RulesDatabase
import io.github.alexandrepiveteau.datalog.dsl.Atom
import io.github.alexandrepiveteau.datalog.dsl.Domain
import io.github.alexandrepiveteau.datalog.dsl.Value

private fun <T> List<Atom<T>>.constants(): Sequence<Value<T>> {
  return sequence {
    for (atom in this@constants) {
      when (atom) {
        is Value -> yield(atom)
        else -> Unit
      }
    }
  }
}

private fun <T> Rule<T>.constants(): Sequence<Value<T>> {
  return sequence {
    yieldAll(atoms.constants())
    for (clause in clauses) {
      yieldAll(clause.atoms.constants())
    }
  }
}

private fun <T> constants(rules: RulesDatabase<T>, facts: FactsDatabase<T>): Sequence<Value<T>> {
  val values = sequence {
    for (predicate in rules) for (rule in rules[predicate]) yieldAll(rule.constants())
    for (predicate in facts) facts[predicate].forEach { yieldAll(it) }
  }
  // TODO : This is a temporary workaround to make sure the values are not recomputed each time the
  //        Context is used. This is to avoid constants generated by aggregates to show up in the
  //        domain, especially if the rules are properly grounded.
  return values.toSet().asSequence()
}

/**
 * An implementation of [Program] to obtain results.
 *
 * @param domain the [Domain] of the program.
 * @param rules the [Rule]s of the program.
 * @param evalStrata the function used to evaluate each stratum.
 */
internal class DatalogProgram<out T>(
    private val domain: Domain<T>,
    private val rules: MutableSet<Rule<T>>,
    private val evalStrata:
        (Context<T>) -> (RulesDatabase<T>, FactsDatabase<T>) -> FactsDatabase<T>,
) : Program<T> {

  private fun context(idb: RulesDatabase<T>, edb: FactsDatabase<T>): Context<T> {
    return Context(atoms = constants(idb, edb), domain = domain)
  }

  override fun solve(predicate: Predicate, arity: Int): Iterable<Fact<T>> {
    val (idb, edb) = partition(rules)
    val target = PredicateWithArity(predicate, arity)
    val result = stratifiedEval(target, idb, edb, evalStrata(context(idb, edb)))
    val facts = result[target]
    return facts.mapToFacts(predicate).asIterable()
  }
}

/** Transforms a [Relation] to a [Sequence] of [Fact]s, which can be output back. */
private fun <T> Relation<T>.mapToFacts(
    predicate: Predicate,
): Sequence<Fact<T>> = sequence { tuples.forEach { yield(Fact(predicate, it)) } }
